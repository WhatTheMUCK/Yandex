# Передача пакетов с балансировкой

**Ограничение времени:** 1 с  
**Ограничение памяти:** 64.0 Мб  
**Ввод:** стандартный ввод или `input.txt`  
**Вывод:** стандартный вывод или `output.txt`

В сети работает серверный кластер, который получает и обрабатывает пакеты данных.

Есть $ k $ одинаковых серверов. Каждый сервер может обрабатывать **только один пакет одновременно**.

Каждый пакет имеет:
- время поступления $ t_i $,
- время обработки $ d_i $.

Балансировщик при поступлении пакета назначает его **серверу с наименьшим временем готовности** (моментом, когда сервер сможет начать обработку нового пакета).  
Если таких серверов несколько — выбирается сервер с **наименьшим индексом**.

Если выбранный сервер свободен в момент $ t_i $, обработка начинается сразу в $ t_i $.  
Иначе — обработка начинается в момент готовности сервера.

На каждом сервере пакеты выполняются **в порядке назначения** (FIFO).

---

## Формат входных данных

Первая строка содержит два целых числа $ n $ и $ k $  
($ 1 \leq n \leq 2 \cdot 10^5,\; 1 \leq k \leq 2 \cdot 10^5 $) — количество пакетов и число серверов.

Следующие $ n $ строк содержат по два целых числа $ t_i $ и $ d_i $  
($ 0 \leq t_i \leq 10^9,\; 1 \leq d_i \leq 10^9 $) — время поступления и длительность обработки $ i $-го пакета.

Пакеты даны **в порядке неубывания** $ t_i $ (то есть $ t_1 \leq t_2 \leq \dots \leq t_n $).  
Если несколько пакетов приходят в один момент времени, они обрабатываются **в порядке их следования во входных данных**.

## Формат выходных данных

Выведите $ n $ чисел — моменты **завершения обработки** каждого пакета (в том же порядке, в каком они даны во входных данных).

---

## Пример 1

**Ввод:**
```
5 2
0 5
1 2
1 3
6 4
6 1
```

**Вывод:**
```
5 3 6 10 7
```

## Пример 2

**Ввод:**
```
4 3
0 4
0 2
1 3
5 1
```

**Вывод:**
```
4 2 4 6
```
## Решение

main.cpp
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, k;
    std::cin >> n >> k;

    std::priority_queue<
        std::pair<long long, int>,
        std::vector<std::pair<long long, int>>,
        std::greater<std::pair<long long, int>>> pq;

    for (int i = 0; i < k; ++i) {
        pq.push({0, i});
    }

    std::vector<long long> result(n);

    for (int i = 0; i < n; ++i) {
        long long t, d;
        std::cin >> t >> d;

        auto [readyTime, serverId] = pq.top();
        pq.pop();

        long long start = std::max(readyTime, t);
        long long finish = start + d;
        result[i] = finish;

        pq.push({finish, serverId});
    }

    for (int i = 0; i < n; ++i) {
        if (i > 0) std::cout << ' ';
        std::cout << result[i];
    }
    std::cout << '\n';

    return 0;
}
```
