# Печеньки

**Ограничение времени:** 1 с  
**Ограничение памяти:** 64.0 Мб  
**Ввод:** стандартный ввод или `input.txt`  
**Вывод:** стандартный вывод или `output.txt`

Вася в офисе на кофебрейке решил набрать печенек трёх видов:

- с шоколадом (`A`)
- с орехами (`B`)
- с изюмом (`C`)

Он хочет взять цепочку печенек длины $N$, но при этом так, что **в любой тройке подряд идущих печенек первая и последняя печенька не совпадают**.

Другими словами, в последовательности **не должно быть подстроки длины 3**, где первый и третий символ одинаковые (например, `ABA`, `CCC`, `BAB` — запрещены; `ABC`, `ABB`, `ACB` — разрешены).

Ваша задача — посчитать количество способов собрать такую цепочку.

## Формат входных данных

В единственной строке дано одно натуральное число $N$ — длина цепочки печенек ($1 \leq N \leq 10^6$).

## Формат выходных данных

Выведите одно целое число — количество допустимых последовательностей длины $N$, в которых **не встречается подстрока длиной 3 с совпадающими первым и третьим символом**.  
Ответ выведите **по модулю** $1\,000\,000\,007$.

## Примеры

### Пример 1

**Ввод:**
```
5
```

**Вывод:**
```
72
```

### Пример 2

**Ввод:**
```
7
```

**Вывод:**
```
288
```
## Решение

main.cpp
```cpp
#include <iostream>
#include <vector>

const long long MOD = 1'000'000'007;

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n;
    std::cin >> n;

    if (n == 1) {
        std::cout << "3\n";
        return 0;
    }

    // Кодируем состояние как 3 * first + second, где A=0, B=1, C=2
    std::vector<long long> dp(9, 1); // все 9 пар: AA, AB, ..., CC

    for (int i = 3; i <= n; ++i) {
        std::vector<long long> new_dp(9, 0);
        for (int cur = 0; cur < 9; ++cur) {
            int first = cur / 3;       // первый символ текущего состояния

            for (int state = 0; state < 3; ++state) {
                if (first == state) continue;

                int prev = state * 3 + first;
                new_dp[cur] = (new_dp[cur] + dp[prev]) % MOD;
            }
        }
        dp = std::move(new_dp);
    }

    long long ans = 0;
    for (long long x : dp) {
        ans = (ans + x) % MOD;
    }
    std::cout << ans << '\n';
}
```
