# Минимальная суммарная длина отрезков

**Ограничение времени:** 1 с  
**Ограничение памяти:** 256.0 Мб  
**Ввод:** стандартный ввод или `input.txt`  
**Вывод:** стандартный вывод или `output.txt`

Заданы $n$ точек на прямой.  
Требуется покрыть все точки **ровно $k$ отрезками** (можно использовать меньше, если $k$ больше необходимого минимума, но не обязательно использовать все $k$), так чтобы **суммарная длина всех отрезков была минимальной**.

> Отрезки могут иметь **нулевую длину** (например, покрывать одну точку).  
> Цель — минимизировать **сумму длин** отрезков, а не их количество.

## Формат ввода

- Первая строка: два целых числа $n$ и $k$  
  ($1 \leq n \leq 10^5$, $1 \leq k \leq 10^9$).
- Вторая строка: $n$ целых чисел $x_i$ — координаты точек  
  ($-10^9 \leq x_i \leq 10^9$).

## Формат вывода

Выведите одно целое число — **минимальную суммарную длину** $k$ отрезков, покрывающих все точки.

> Если $k \geq n$, можно покрыть каждую точку отдельным отрезком нулевой длины → ответ `0`.

## Примеры

### Пример 1

**Ввод:**
```
5 2
1 1 3 4 5
```

**Вывод:**
```
2
```

### Пример 2

**Ввод:**
```
5 1000000000
1 1 3 4 5
```

**Вывод:**
```
0
```

### Пример 3

**Ввод:**
```
10 3
1 4 2 10 20 11 12 14 19 15
```

**Вывод:**
```
9
```
## Решение

main.cpp
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>


int main() {
    int n, k;
    std::cin >> n >> k;
    std::vector<int> x(n);
    std::vector<unsigned int> distances(n - 1);
    for (int i = 0; i < n; ++i) {
        std::cin >> x[i];
        
    }
    std::sort(x.begin(), x.end());
    for (int i = 1; i < n; ++i) {
        distances[i - 1] = x[i] - x[i - 1];
    }

    if (k >= n) {
        std::cout << "0\n";
        return 0;
    }

    std::sort(distances.begin(), distances.end(), std::greater<int>());
    std::cout << std::accumulate(distances.begin() + (k - 1), distances.end(), 0ll) << '\n';

    return 0;
}
```
