# Сбалансированные книги

**Ограничение времени:** 1 с  
**Ограничение памяти:** 64.0 Мб  
**Ввод:** стандартный ввод или `input.txt`  
**Вывод:** стандартный вывод или `output.txt`

В библиотеке книги лежат в стопке. Каждая книга имеет «тип» — целое число.  
Библиотекарь хочет найти **непрерывный отрезок** стопки, который можно переложить на отдельную полку так, чтобы он образовывал **сбалансированную композицию**.

## Определение сбалансированного отрезка

Последовательность книг считается **сбалансированной**, если:

- Типы книг **чередуются по чётности**: чётное → нечётное → чётное → нечётное → …  
  **или**  
  нечётное → чётное → нечётное → чётное → …
- При этом **каждое нечётное число должно иметь пару — чётное число, идущее после него** в отрезке (и наоборот, в зависимости от начала), так что отрезок «замыкается» корректно.

> На практике, в контексте приведённых примеров, под «сбалансированной» композицией подразумевается **максимальный непрерывный отрезок, в котором чётные и нечётные числа строго чередуются**.

Таким образом, задача сводится к:  
**Найти длину самого длинного подмассива, в котором чётность элементов строго чередуется.**

---

## Формат входных данных

- Первая строка: целое число $ n $ ($ 1 \leq n \leq 2 \cdot 10^5 $) — количество книг.
- Вторая строка: $ n $ целых чисел — типы книг (значения могут быть любыми целыми).

## Формат выходных данных

Выведите одно целое число — длину **самого длинного сбалансированного отрезка**.

---

## Примеры

### Пример 1

**Ввод:**
```
10
4 3 6 5 8 10 7 12 9 14
```

**Вывод:**
```
4
```

### Пример 2

**Ввод:**
```
8
6 3 5 8 10 7 12 9
```

**Вывод:**
```
6
```

## Примечание

**Ограничения:**

- $ 1 \leq n \leq 2 \cdot 10^5 $
- Типы книг — произвольные целые числа.
## Решение

main.cpp
```cpp
#include <iostream>
#include <stack>
#include <vector>
#include <algorithm>


int main() {
    int n;
    std::cin >> n;
    int answer = 0;
    std::stack<long long> st;
    std::vector<std::pair<int, int>> pairs;
    for (int i = 0; i < n; ++i) {
        long long book;
        std::cin >> book;
        book = ((book  % 2) + 2) % 2;
        if (st.empty()) {
            if (book == 0) {
                continue;
            }

            st.push(i);
            continue;
        }

        if (book == 0) {
            int left = st.top();
            st.pop();
            pairs.push_back({left, i});

        } else {
            st.push(i);
        }
    }
    std::sort(pairs.begin(), pairs.end());
    std::vector<std::pair<int, int>> pairsEdited;
    for (size_t i = 0; i < pairs.size(); ++i) {
        if (i == 0) {
            pairsEdited.push_back(pairs[i]);
            continue;
        } 

        auto [left1, right1] = pairsEdited.back();
        auto [left2, right2] = pairs[i];
        if (left2 < right1 || right1 + 1 == left2) {
            int left = std::min(left1, left2);
            int right = std::max(right1, right2);
            pairsEdited.back() = {left, right};
        } else {
            pairsEdited.push_back(pairs[i]);
        }
    }

    for (const auto & [l, r] : pairsEdited) {
        answer = std::max(answer, r - l + 1);
    }

    std::cout << answer << '\n';
    return 0;
}
```
