# Выполнение операций с деком

**Ограничение времени:** 2 с  
**Ограничение памяти:** 256.0 Мб  
**Ввод:** стандартный ввод или `input.txt`  
**Вывод:** стандартный вывод или `output.txt`

Дана последовательность команд, управляющих двусторонней очередью (деком). Необходимо выполнить все команды и после каждой операции вывести состояние дека.

Изначально у вас есть пустой дек. Далее поступает $ q $ запросов. Каждый запрос одного из следующих типов:

- **Тип 1:** `1 x` — положить число $ x $ в **начало** дека.  
- **Тип 2:** `2 x` — положить число $ x $ в **конец** дека.  
- **Тип 3:** `3` — удалить число из **начала** дека.  
- **Тип 4:** `4` — удалить число из **конца** дека.

После каждого запроса необходимо вывести два числа:  
- сначала элемент в **начале** дека,  
- затем элемент в **конце** дека.

Если дек пуст, выведите `-1`.

---

## Формат входных данных

Первая строка содержит целое число $ q $ — количество запросов.  
Далее следуют $ q $ строк, каждая из которых описывает один запрос в соответствии с указанными выше правилами.

## Формат выходных данных

Выведите $ q $ строк. В каждой строке:

- два числа — первый и последний элементы дека,  
- или `-1`, если дек пуст.

---

## Пример 1

**Ввод:**
```
10
1 5
2 7
1 3
4
3
2 8
2 9
3
4
4
```

**Вывод:**
```
5 5
5 7
3 7
3 5
5 5
5 8
5 9
8 9
8 8
-1
```

## Пример 2

**Ввод:**
```
7
1 10
2 20
1 5
3
4
3
4
```

**Вывод:**
```
10 10
10 20
5 20
10 20
10 10
-1
-1
```

---

## Примечание

**Ограничения:**

- $ 1 \leq q \leq 10^6 $
- Для всех запросов типов 1 и 2: $ 1 \leq x \leq 10^6 $
## Решение

main.cpp
```cpp
#include <iostream>
#include <deque>

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);

    std::deque<int> dq;
    int n;
    std::cin >> n;
    for (int i = 0; i < n; ++i) {
        int mode, x;
        std::cin >> mode;
        
        switch (mode)
        {
            case 1:
                std::cin >> x;
                dq.push_front(x);
                break;
            case 2:
                std::cin >> x;
                dq.push_back(x);
                break;
            case 3:
                if (dq.empty()) 
                    break;
                dq.pop_front();
                break;
            case 4:
                if (dq.empty()) 
                    break;
                dq.pop_back();
                break;
            default:
                break;
        }

        if (dq.empty()) {
            std::cout << "-1\n";
            continue;
        }

        std::cout << dq.front() << ' ' << dq.back() << '\n';
    }

    return 0;
}
```
