# Планировщик уведомлений

**Ограничение времени:** 1 с  
**Ограничение памяти:** 64.0 Мб  
**Ввод:** стандартный ввод или `input.txt`  
**Вывод:** стандартный вывод или `output.txt`

В системе зарегистрированы периодические уведомления.  
Для каждого уведомления известны:

- **идентификатор** $ id_i $,
- **период срабатывания** $ p_i $,
- **начальное время первого срабатывания** $ s_i $.

## Правила работы системы

- В момент времени $ s_i $ уведомление $ id_i $ срабатывает.
- После каждого срабатывания оно **автоматически перепланируется** на время $ t + p_i $, где $ t $ — текущее время срабатывания.
- Если в **один и тот же момент времени** срабатывают несколько уведомлений, они выводятся **в порядке возрастания их идентификаторов**.

Дано описание $ n $ уведомлений и число $ m $.  
Требуется вывести **идентификаторы первых $ m $ сработавших событий** в хронологическом порядке (с учётом правила сортировки при совпадении времени).

---

## Формат входных данных

- Первая строка: два целых числа $ n $ и $ m $  
  ($ 1 \leq n \leq 2 \cdot 10^5,\; 1 \leq m \leq 2 \cdot 10^5 $).
- Следующие $ n $ строк: по три целых числа $ id_i,\; p_i,\; s_i $, где:
  - $ 1 \leq id_i \leq 10^9 $,
  - $ 1 \leq p_i \leq 10^9 $,
  - $ 0 \leq s_i \leq 10^9 $.

## Формат выходных данных

Выведите $ m $ строк — по одному идентификатору уведомления в порядке срабатывания.

---

## Примеры

### Пример 1

**Ввод:**
```
3 7
10 5 0
7 3 1
20 4 0
```

**Вывод:**
```
10
20
7
7
20
10
7
```

### Пример 2

**Ввод:**
```
2 5
1 2 0
2 3 1
```

**Вывод:**
```
1
2
1
1
2
```

## Решение

main.cpp
```cpp
#include <iostream>
#include <queue>

struct Compare {
    bool operator()(const std::tuple<long long, int, int>& lhs, const std::tuple<long long, int, int>& rhs) const {
        return std::tie(std::get<0>(rhs), std::get<1>(rhs)) < std::tie(std::get<0>(lhs), std::get<1>(lhs));
    }
};

int main() {
    int n, m;
    std::cin >> n >> m;
    std::priority_queue<std::tuple<long long, int, int>, 
                        std::vector<std::tuple<long long, int, int>>,
                        Compare> pq;
    for (int i = 0; i < n; ++i) {
        int id, p, s;
        std::cin >> id >> p >> s;
        pq.push({s, id, p});
    }

    while (m > 0) {
        auto [s, id, p] = pq.top();
        pq.pop();
        std::cout << id << '\n';
        pq.push({s + p, id, p});
        --m;
    }

    return 0;
}
```
