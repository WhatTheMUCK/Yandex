# Ханойские башни 2

**Ограничение времени:** 1 с  
**Ограничение памяти:** 256.0 Мб  
**Ввод:** стандартный ввод или `input.txt`  
**Вывод:** стандартный вывод или `output.txt`

Головоломка **"Ханойские башни"** состоит из **четырёх** стержней, пронумеруем их слева направо: **1**, **2**, **3** и **4**. Также в головоломке используется стопка дисков с отверстием посередине. Радиус дисков уменьшается снизу вверх.

Изначально все диски расположены на **стержне 1**, самый большой диск находится внизу.  
Диски перемещаются **по одному** со стержня на стержень.  
Диск можно надеть на стержень, **только если он пустой или верхний диск на нём больше**, чем перемещаемый.

Цель головоломки — перенести все диски со **стержня 1** на **стержень 4**, используя **минимальное количество ходов**.

## Формат ввода

В первой строке задано одно число $n$ ($3 \leq n \leq 10$) — количество дисков на первой башне.

## Формат вывода

В единственной строке выведите **минимальное количество ходов**, необходимое для решения головоломки.

## Примеры

### Пример 1

**Ввод:**
```
3
```

**Вывод:**
```
5
```

### Пример 2

**Ввод:**
```
4
```

**Вывод:**
```
9
```

### Пример 3

**Ввод:**
```
5
```

**Вывод:**
```
13
```
## Решение

main.cpp
```cpp
#include <iostream>
#include <unordered_map>
#include <climits>
#include <cmath>

std::unordered_map<int, long long> memo4;

long long moves3(int n) {
    if (n <= 0) return 0;
    return (1LL << n) - 1;
}

long long moves4(int n) {
    if (n <= 0) return 0;
    if (n == 1) return 1;

    if (memo4.contains(n)) {
        return memo4[n];
    }

    long long best = LLONG_MAX;
    for (int k = 1; k < n; ++k) {
        long long candidate = 2 * moves4(k) + moves3(n - k);
        if (candidate < best) {
            best = candidate;
        }
    }

    memo4[n] = best;
    return best;
}

int main() {
    int n;
    std::cin >> n;
    std::cout << moves4(n) << '\n';
    return 0;
}
```
