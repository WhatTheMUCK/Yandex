# Приоритетная очередь

**Ограничение времени:** 1 с  
**Ограничение памяти:** 64.0 Мб  
**Ввод:** стандартный ввод или `input.txt`  
**Вывод:** стандартный вывод или `output.txt`

Изначально у вас есть пустая **очередь с приоритетом** (max-heap).  
Далее поступает $ q $ запросов. Каждый запрос одного из следующих типов:

- **Тип 1:** `1 x` — добавить число $ x $ в очередь.  
- **Тип 2:** `2` — извлечь из очереди элемент с **наибольшим значением**.

После **каждого** запроса необходимо вывести:

- **максимальный элемент** в очереди (т.е. элемент на вершине кучи),  
- или `-1`, если очередь пуста.

> **Гарантия:** при поступлении запроса второго типа очередь **не пуста**.

---

## Формат входных данных

- Первая строка: целое число $ q $ — количество запросов.  
- Далее $ q $ строк, каждая из которых:
  - `1 x` — добавление числа $ x $,
  - `2` — извлечение максимума.

**Ограничения:**
- $ 1 \leq q \leq 2 \cdot 10^5 $
- $ |x| \leq 10^9 $

## Формат выходных данных

Выведите $ q $ строк. Каждая строка содержит:

- текущий максимум в очереди после выполнения запроса,  
- или `-1`, если очередь пуста.

---

## Примеры

### Пример 1

**Ввод:**
```
6
1 5
1 3
1 10
2
2
2
```

**Вывод:**
```
5
5
10
5
3
-1
```

### Пример 2

**Ввод:**
```
7
1 2
1 8
2
1 5
2
2
2
```

**Вывод:**
```
2
8
2
5
2
-1
-1
```
## Решение

main.cpp
```cpp
#include <iostream>
#include <queue>

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);

    int n;
    std::cin >> n;
    std::priority_queue<int> pq;
    for (int i = 0; i < n; ++i) {
        int mode;
        std::cin >> mode;
        if (mode == 1) {
            int x;
            std::cin >> x;
            pq.push(x);
        } else if (mode == 2) {
            if (!pq.empty()) {
                pq.pop();
            }
        }

        std::cout << (pq.empty() ? -1 : pq.top()) << '\n';
    }
    return 0;
}
```
