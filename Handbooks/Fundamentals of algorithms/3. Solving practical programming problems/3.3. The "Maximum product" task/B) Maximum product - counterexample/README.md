# Максимальное произведение — контрпример

**Ограничение времени:** 1 с  
**Ограничение памяти:** 256.0 Мб  
**Ввод:** стандартный ввод или `input.txt`  
**Вывод:** стандартный вывод или `output.txt`

Рассмотрим следующий алгоритм поиска максимального попарного произведения:

```
MaxPairwiseProduct(A[1..n]):
    m1 = A[1]
    m2 = A[2]
    if m2 > m1:
        swap(m1, m2)

    for i from 3 to n:
        if A[i] > m1:
            m2 = m1
            m1 = A[i]
        else:
            if A[i] > m2:
                m2 = A[i]
    return m1 * m2
```

В этом алгоритме:
- На каждой итерации цикла выполняется **ровно одно** сравнение `A[i] > m1`.
- **Дополнительное** сравнение `A[i] > m2` выполняется **только если** первое условие ложно.

Таким образом, общее число сравнений равно:
- $ 1 $ (на шаге инициализации: `if m2 > m1`),
- плюс $ n - 2 $ (по одному на каждую итерацию цикла для `A[i] > m1`),
- плюс количество итераций, где `A[i] <= m1` **и** `A[i] > m2`.

Обозначим это количество как $ t $. Тогда общее число сравнений:
$$
C = 1 + (n - 2) + t = n - 1 + t
$$

Нам нужно, чтобы $ C > 1.5n $, то есть:
$$
n - 1 + t > 1.5n \quad \Rightarrow \quad t > 0.5n + 1
$$

Поскольку $ t \leq n - 2 $, такое возможно **только если** почти все элементы после первых двух удовлетворяют условию `A[i] <= m1` и `A[i] > m2`.

Это достигается, например, когда:
- первый элемент — **максимальный** (чтобы `A[i] > m1` **никогда не выполнялось**),
- второй элемент — **минимальный**,
- остальные элементы — **строго больше второго**, но **меньше первого**.

Тогда:
- `m1 = A[1]` остаётся неизменным,
- `m2` будет обновляться на каждом шаге цикла → $ t = n - 2 $,
- общее число сравнений: $ C = n - 1 + (n - 2) = 2n - 3 $.

Условие $ 2n - 3 > 1.5n $ выполняется при $ n > 6 $.

---

## Формат ввода

Целое число $ n $ ($ 2 \leq n \leq 200\,000 $).

## Формат вывода

- Если **невозможно** построить такой пример (например, при малых $ n $), выведите `No`.
- Иначе:
  - В первой строке: `Yes`,
  - Во второй строке: $ n $ целых чисел $ a_1, a_2, \dots, a_n $ ($ 0 \leq a_i \leq 200\,000 $), образующих требуемый контрпример.

> Если подходящих последовательностей несколько, выведите любую.

---

## Примеры

### Пример 1

**Ввод:**
```
2
```

**Вывод:**
```
No
```

### Пример 2

**Ввод:**
```
10
```

**Вывод:**
```
Yes
10 1 2 3 4 5 6 7 8 9
```
## Решение

main.cpp
```cpp
#include <iostream>

int main() {
    int n;
    std::cin >> n;
    if (n < 7) {
        std::cout << "NO\n";
        return 0;
    }

    std::cout << "YES\n";
    std::cout << n;
    for (int i = 1; i < n; ++i) {
        std::cout << ' ' << i;
    }
    std::cout << '\n';
    
    return 0;
}
```
