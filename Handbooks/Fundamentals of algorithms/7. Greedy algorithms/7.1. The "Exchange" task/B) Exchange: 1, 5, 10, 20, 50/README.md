# Размен: 1, 5, 10, 20, 50

**Ограничение времени:** 2 с  
**Ограничение памяти:** 256.0 Мб  
**Ввод:** стандартный ввод или `input.txt`  
**Вывод:** стандартный вывод или `output.txt`

Предположим, что у кассира есть **бесконечное количество монет** номиналами **1**, **5**, **10**, **20** и **50**.

Найдите **набор монет**, суммарный номинал которых равен `money`, и **количество монет в наборе минимально**.

Требуется вывести **номиналы монет** в таком оптимальном наборе.

> Поскольку система номиналов является **канонической**, жадный алгоритм (выбор наибольшего возможного номинала на каждом шаге) даёт оптимальное решение.

## Формат ввода

Целое число `money` ($1 \leq \text{money} \leq 10^5$).

## Формат вывода

- В первой строке выведите количество монет в наборе $m$.
- Во второй строке выведите номиналы монет через пробел (в **любом порядке**).

## Примеры

### Пример 1

**Ввод:**
```
7
```

**Вывод:**
```
3
5 1 1
```

### Пример 2

**Ввод:**
```
10
```

**Вывод:**
```
1
10
```

### Пример 3

**Ввод:**
```
1
```

**Вывод:**
```
1
1
```
## Решение

main.cpp
```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
#include <numeric>

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);

    int money;
    std::cin >> money;
    std::vector<int> nominals = {0, 0, 0, 0, 0};
    std::unordered_map<int, int> mp = {
        {0, 50}, {1, 20}, {2, 10}, {3, 5}, {4, 1} 
    };

    for (size_t i = 0; i < nominals.size(); ++i) {
        nominals[i] += money / mp[i];
        money %= mp[i];
    }

    std::cout << std::accumulate(nominals.begin(), nominals.end(), 0ll) << '\n';
    bool first = true;
    for (size_t i = 0; i < nominals.size(); ++i) {
        for ( ;nominals[i] > 0; --nominals[i]) {
            if (!first) std::cout << ' ';
            std::cout << mp[i];
            first = false;
        }
    }
    std::cout << '\n';

    return 0;
}
```
