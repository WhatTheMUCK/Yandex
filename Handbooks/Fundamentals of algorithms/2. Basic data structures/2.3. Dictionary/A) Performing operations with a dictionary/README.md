# Выполнение операций со словарем

**Ограничение времени:** 1 с  
**Ограничение памяти:** 256.0 Мб  
**Ввод:** стандартный ввод или `input.txt`  
**Вывод:** стандартный вывод или `output.txt`

Изначально у вас есть пустой словарь. Далее вам поступает $q$ запросов. Каждый запрос одного из следующих типов:

- **Запрос 1-го типа**: поставить в соответствие ключу $x$ число $y$.  
- **Запрос 2-го типа**: проверить, какое число соответствует ключу $x$.

Считайте, что изначально каждому ключу соответствует число $-1$.

## Формат ввода

Первая строка содержит единственное число $q$ — количество запросов.

Далее следует $q$ строк. Каждая из этих строк может иметь один из следующих видов:

- Для запроса первого типа: `1 x y` (без кавычек).  
- Для запроса второго типа: `2 x` (без кавычек).

## Формат вывода

Вывод должен состоять из $count$ строк, где $count$ — количество запросов второго типа.  
Каждая строка должна содержать одно число, которое соответствует ключу.

## Пример

**Ввод**
```
9
1 2 3
2 1
2 2
1 1 4
2 1
2 2
1 2 5
2 1
2 2
```

**Вывод**
```
-1
3
4
3
4
5
```

## Примечание

**Ограничения:**

- $1 \leq q \leq 1 \cdot 10^5$  
- Для запросов первого типа: $1 \leq x, y \leq 10^9$  
- Для запросов второго типа: $1 \leq x \leq 10^9$
## Решение

main.cpp
```cpp
#include <iostream>
#include <unordered_map>

int main() {
    std::cin.tie(0);
    std::ios::sync_with_stdio(0);
    
    int q;
    std::cin >> q;
    std::unordered_map<int, int> mp;
    for (int i = 0; i < q; ++i) {
        int flag, x;
        std::cin >> flag >> x;
        if (flag == 1) {
            int y;
            std::cin >> y;
            mp[x] = y;
            continue;
        }

        int answer = mp[x];
        if (answer == 0) answer = -1;
        std::cout << answer << '\n';
    }
    return 0;
}
```
