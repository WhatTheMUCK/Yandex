# Наибольшее число шагов алгоритма Евклида

**Ограничение времени:** 1 с  
**Ограничение памяти:** 256.0 Мб  
**Ввод:** стандартный ввод или `input.txt`  
**Вывод:** стандартный вывод или `output.txt`

Алгоритм Евклида можно записать в рекурсивной форме:

```
GCD(a, b):
    if a = 0 or b = 0:
        return max(a, b)
    return GCD(b, a mod b)
```

Вызов функции `GCD(5, 0)` не порождает дополнительных рекурсивных вызовов.  
А вызов `GCD(5, 2)` порождает вызовы `GCD(2, 1)` и `GCD(1, 0)`.

Количество шагов алгоритма Евклида будет равняться количеству вызовов функции `GCD` для заданных значений $a$ и $b$.

Дано число $n$, найдите значения $a$ и $b$ ($0 \leq a, b \leq n$), для которых количество вызовов функции `GCD` будет наибольшим.

## Формат ввода

Целое число $n$.

**Ограничения:**  
$$
1 \leq n \leq 10^9
$$

## Формат вывода

Значения $a$ и $b$ (разделённые пробелом).

Если существует несколько пар значений $a$ и $b$, для которых количество вызовов функции `GCD` наибольшее, то выведите любую из таких пар.

## Примеры

### Пример 1

**Ввод**  
```
3
```

**Вывод**  
```
2 3
```

### Пример 2

**Ввод**  
```
10
```

**Вывод**  
```
5 8
```

### Пример 3

**Ввод**  
```
10000
```

**Вывод**  
```
4181 6765
```
## Решение

main.cpp
```cpp
#include <iostream>

int main() {
    int n;
    std::cin >> n;
    int f1 = 1, f2 = 1;
    while (f2 < n) {
        int tmp = f1;

        if (f2 + tmp > n) {
            break;
        }
        
        f1 = f2;
        f2 = f1 + tmp;
    }
    std::cout << f1 << ' ' << f2 << '\n';
    return 0;
}
```
