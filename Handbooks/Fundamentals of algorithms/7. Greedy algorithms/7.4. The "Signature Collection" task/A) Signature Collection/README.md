# Сбор подписей

**Ограничение времени:** 1 с  
**Ограничение памяти:** 256.0 Мб  
**Ввод:** стандартный ввод или `input.txt`  
**Вывод:** стандартный вывод или `output.txt`

Ваша задача — собрать подписи всех жильцов в доме.  
Известно, что каждый жилец находится дома в течение некоторого **временного интервала** (сегмента).  
Когда вы приходите в дом в момент времени $t$, вы **сразу получаете подписи всех**, кто находится дома в этот момент (то есть всех, чьи интервалы содержат $t$).

Требуется найти **минимальное количество визитов**, чтобы собрать **все подписи**, и указать **моменты времени**, когда нужно прийти.

> Это классическая задача о **минимальном покрытии отрезков точками**.

## Формат ввода

- Первая строка: целое число $n$ — количество жильцов (интервалов) ($1 \leq n \leq 100$).
- Следующие $n$ строк: по два целых числа $l_i$ и $r_i$ — начало и конец интервала присутствия $i$-го жильца  
  ($0 \leq l_i \leq r_i \leq 10^9$).

## Формат вывода

- Первая строка: целое число $k$ — минимальное количество визитов.
- Вторая строка: $k$ целых чисел — моменты времени (координаты точек), в которые нужно прийти.  
  Порядок точек — **любой**. Если решений несколько — выведите **любое**.

## Примеры

### Пример 1

**Ввод:**
```
3
1 3
2 5
3 6
```

**Вывод:**
```
1
3
```

### Пример 2

**Ввод:**
```
4
4 7
1 3
2 5
3 6
```

**Вывод:**
```
2
3 7
```
## Решение

main.cpp
```cpp
#include <iostream>
#include <vector>
#include <algorithm>


int main() {
    int n;
    std::cin >> n;
    std::vector<std::pair<int, int>> timings(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> timings[i].first >> timings[i].second;
    }
    std::sort(timings.begin(), timings.end(), [](const auto & lhs, const auto & rhs){
        return std::tie(lhs.second, lhs.first) < std::tie(rhs.second, rhs.first);
    });

    std::vector<int> correctTimings;
    for (int i = 0; i < n; ++i) {
        if (!correctTimings.empty() && timings[i].first <= correctTimings.back()) {
            continue;
        }

        correctTimings.push_back(timings[i].second);
        continue;
    }

    std::cout << correctTimings.size() << '\n';
    for (size_t i = 0; i < correctTimings.size(); ++i) {
        if (i > 0) std::cout << ' ';
        std::cout << correctTimings[i];
    }
    std::cout << '\n';

    return 0;
}
```
