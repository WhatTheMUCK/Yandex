# Удаление локальных минимумов

**Ограничение времени:** 1 с  
**Ограничение памяти:** 256.0 Мб  
**Ввод:** стандартный ввод или `input.txt`  
**Вывод:** стандартный вывод или `output.txt`

Дан массив `a`, состоящий из `n` чисел.

Позиция `i` является **локальным минимумом**, если для неё выполнены условия:  
`2 ≤ i ≤ n − 1` и `a[i−1] > a[i] < a[i+1]`.

Требуется удалить из массива все элементы, стоящие в позициях локальных минимумов, определённых **относительно исходного массива**.

## Формат ввода

Первая строка содержит единственное число `n` — количество чисел в массиве.

Вторая строка содержит `n` чисел `a_i`, где `a_i` — число на `i`-й позиции в массиве `a`. Числа разделены пробелами.

**Ограничения:**  
`3 ≤ n ≤ 10^5`;  
`1 ≤ a_i ≤ 10^5` для всех `1 ≤ i ≤ n`.

## Формат вывода

Первая строка должна содержать одно число `k` — количество элементов в массиве, которые остались после удаления.

Вторая строка должна содержать `k` чисел, разделённых пробелами — оставшиеся элементы массива `a`.

## Пример 1

Ввод:
```
5
1 3 2 5 4
```

Вывод:
```
4
1 3 5 4
```

## Пример 2

Ввод:
```
5
3 2 1 2 3
```

Вывод:
```
4
3 2 2 3
```

## Пример 3

Ввод:
```
6
5 3 1 2 4 6
```

Вывод:
```
5
5 3 2 4 6
```

## Пример 4

Ввод:
```
7
2 1 2 1 2 1 2
```

Вывод:
```
4
2 2 2 2
```
## Решение

main.cpp
```cpp
#include <iostream>
#include <vector>


int main() {
    int n;
    std::cin >> n;
    std::vector<int> vec(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> vec[i];
    }

    std::vector<int> answer;
    for (int i = 0; i < n; ++i) {
        if (i == 0 || i == n - 1) {
            answer.push_back(vec[i]);
            continue;
        }

        if (vec[i - 1] > vec[i] && vec[i] < vec[i + 1]) {
            continue;
        }
        answer.push_back(vec[i]);
    }

    int k = static_cast<int>(answer.size());
    std::cout << k << '\n';
    for (int i = 0; i < k; ++i) {
        if (i > 0) std::cout << ' ';
        std::cout << answer[i];
    }
    std::cout << '\n';

    return 0;
}
```
