# Множественный поиск ключей в отсортированной последовательности

**Ограничение времени:** 1 с  
**Ограничение памяти:** 256.0 Мб  
**Ввод:** стандартный ввод или `input.txt`  
**Вывод:** стандартный вывод или `output.txt`

## Условие задачи

Дан отсортированный по возрастанию массив $K$ из $n$ **неповторяющихся** целых чисел.  
Также задан массив запросов $Q = [q_0, q_1, \dots, q_{m-1}]$.

Для каждого запроса $q_i$ требуется определить:
- **индекс** элемента в массиве $K$, равного $q_i$ (нумерация с нуля),
- или вывести $-1$, если такого элемента нет.

## Формат ввода

- Первая строка: целое число $n$ — размер массива $K$.  
- Вторая строка: $n$ целых чисел $k_0 < k_1 < \dots < k_{n-1}$.  
- Третья строка: целое число $m$ — количество запросов.  
- Четвёртая строка: $m$ целых чисел $q_0, q_1, \dots, q_{m-1}$.

**Ограничения:**  
$1 \leq n \leq 3 \cdot 10^4$,  
$1 \leq m \leq 10^5$,  
$1 \leq k_i \leq 10^9$ для всех $0 \leq i < n$,  
$1 \leq q_j \leq 10^9$ для всех $0 \leq j < m$.

## Формат вывода

Для каждого $i$ от $0$ до $m-1$ выведите в отдельной строке:
- индекс $j$, такой что $k_j = q_i$, если такой элемент существует,
- $-1$, если элемента $q_i$ в массиве $K$ нет.

## Примеры

### Пример 1

**Ввод:**
```
7
1 3 7 8 9 12 15
1
8
```

**Вывод:**
```
3
```

### Пример 2

**Ввод:**
```
7
1 3 7 8 9 12 15
3
1 12 3
```

**Вывод:**
```
0
5
1
```

### Пример 3

**Ввод:**
```
2
1 1000000000
3
1000000000 54321 1
```

**Вывод:**
```
1
-1
0
```
## Решение

main.cpp
```cpp
#include <iostream>
#include <vector>

std::istream & operator>>(std::istream & is, std::vector<int> & rhs) {
    for (size_t i = 0; i < rhs.size(); ++i) {
        is >> rhs[i];
    }
    return is;
}

int main() {
    int n, m;
    std::cin >> n;
    std::vector<int> k(n);
    std::cin >> k;
    
    std::cin >> m;
    std::vector<int> q(m);
    std::cin >> q;

    for (int i = 0; i < m; ++i) {
        int l = 0, r = n - 1;
        while (l < r) {
            int middle = (l + r) / 2;
            if (k[middle] == q[i]) {
                l = middle;
                break;
            }

            if (k[middle] < q[i]) {
                l = middle + 1;
            } else {
                r = middle - 1;
            }
        }

        if (l < n && k[l] == q[i]) {
            std::cout << l << '\n';
        } else {
            std::cout << "-1\n";
        }
    }

    return 0;
}
```
