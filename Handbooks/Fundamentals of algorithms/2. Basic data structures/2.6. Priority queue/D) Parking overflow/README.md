# Переполнение парковки

**Ограничение времени:** 1 с  
**Ограничение памяти:** 64.0 Мб  
**Ввод:** стандартный ввод или `input.txt`  
**Вывод:** стандартный вывод или `output.txt`

В торговом центре есть парковка на $ k $ мест.  
Приезжает $ n $ автомобилей. Для каждого автомобиля известны:

- момент прибытия $ a_i $,
- момент отбытия $ b_i $,  
  причём $ a_i < b_i $.

Автомобиль приезжает в момент $ a_i $.  
Если **в этот момент** на парковке есть хотя бы одно свободное место, он **занимает его** до момента $ b_i $.  
Если парковка **полностью занята**, автомобиль **уезжает и не паркуется**.

> Машины обрабатываются **в порядке прибытия** (вход отсортирован по $ a_i $).

Требуется определить, **сколько автомобилей успешно припаркуются**.

---

## Формат входных данных

- Первая строка: два целых числа $ n, k $  
  ($ 1 \leq n \leq 2 \cdot 10^5,\; 1 \leq k \leq n $).
- Следующие $ n $ строк: по два целых числа $ a_i, b_i $  
  ($ 0 \leq a_i < b_i \leq 10^9 $).

Гарантируется, что $ a_1 \leq a_2 \leq \dots \leq a_n $.

## Формат выходных данных

Выведите одно целое число — количество автомобилей, которые **смогли припарковаться**.

---

## Примеры

### Пример 1

**Ввод:**
```
5 2
1 4
2 5
3 6
4 7
5 8
```

**Вывод:**
```
4
```

### Пример 2

**Ввод:**
```
6 3
0 5
1 4
2 8
3 7
6 9
8 10
```

**Вывод:**
```
5
```
## Решение

main.cpp
```cpp
#include <iostream>
#include <queue>

int main() {
    int n;
    size_t k;
    std::cin >> n >> k;
    std::priority_queue<int, std::vector<int>, std::greater<int>> pq;
    int answer = 0;
    for (int i = 0; i < n; ++i) {
        int a, b;
        std::cin >> a >> b;
        while (!pq.empty() && pq.top() <= a) {
            pq.pop();
        }

        if (pq.size() == k) {
            continue;
        }

        ++answer;
        pq.push(b);
    }

    std::cout << answer << '\n';
    return 0;
}
```
