# Минимум на отрезке

**Ограничение времени**  
 10 с  
**Ограничение памяти**  
 128.0 Мб  
**Ввод**  
 стандартный ввод или input.txt  
**Вывод**  
 стандартный вывод или output.txt  

Рассмотрим последовательность целых чисел длины `n`. По ней с шагом 1 двигается «окно» длины `k`. Другими словами, сначала в «окне» видны первые `k` чисел, на следующем шаге в «окне» уже будут находиться `k` чисел, начиная со второго, и так далее до конца последовательности. Требуется для каждого положения «окна» определить в нём минимальное число.

---

### Формат ввода

В первой строке входных данных содержатся два натуральных числа `n` и `k` — длины последовательности и «окна».  
При этом:  
 `n ⩽ 150000`,  
 `k ⩽ 10000`,  
 `k ⩽ n`.  

На следующей строке находятся `n` чисел — сама последовательность.

---

### Формат вывода

Выходные данные должны содержать `n − k + 1` строк — минимумы для каждого положения «окна».

---

### Пример

**Ввод:**
```text
7 3
1 3 2 4 5 3 1
```

**Вывод:**
```text
1
2
2
3
1
```

---

### Примечание

Для решения задачи рекомендуется использовать `std::multiset` для хранения окна. Решение с непосредственным подсчётом минимума для каждого положения окна будет неэффективным.
## Решение

main.cpp
```cpp
#include <iostream>
#include <vector>
#include <deque>

std::ostream & operator<<(std::ostream & os, const std::pair<int, int> & rhs) {
    return os << '(' << rhs.first << ' ' << rhs.second << ')';
}

int main() {
    int n, k;
    std::cin >> n >> k;
    std::vector<int> vec(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> vec[i];
    }

    std::deque<std::pair<int, int>> window;
    for (int i = 0; i < n; ++i) {
        while (!window.empty() && window.front().second <= i - k) {
            window.pop_front();
        }

        while (!window.empty() && vec[i] <= window.back().first) {
            window.pop_back();
        }

        window.push_back({vec[i], i});

        if (i >= k - 1) {
            std::cout << window.front().first << '\n';
        }
    }

    return 0;
}
```
