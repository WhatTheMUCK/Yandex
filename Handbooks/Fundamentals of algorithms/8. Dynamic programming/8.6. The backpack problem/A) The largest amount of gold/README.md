# Наибольшее количество золота

**Ограничение времени:** 1 с  
**Ограничение памяти:** 256.0 Мб  
**Ввод:** стандартный ввод или `input.txt`  
**Вывод:** стандартный вывод или `output.txt`

## Условие задачи

Вы нашли несколько золотых слитков. Ваша цель — положить как можно **больше золота** в рюкзак с вместимостью $W$, то есть в нём можно унести максимум $W$ фунтов.

Каждый слиток доступен **в единственном экземпляре**. Вы можете либо **взять** слиток целиком, либо **не брать** его (взять часть слитка нельзя).

Требуется определить **максимальный вес золотых слитков**, который можно уместить в рюкзак вместимостью $W$.

Это классическая задача о **рюкзаке (0/1 knapsack)**.

## Формат ввода

- Первая строка содержит два целых числа:  
  $W$ — вместимость рюкзака,  
  $n$ — количество золотых слитков.
- Вторая строка содержит $n$ целых чисел:  
  $w_1, w_2, \dots, w_n$ — веса слитков.

**Ограничения:**  
$1 \leq W \leq 10^4$,  
$1 \leq n \leq 300$,  
$0 \leq w_i \leq 10^5$.

## Формат вывода

Выведите одно целое число — **максимальный вес**, который можно унести в рюкзаке вместимостью $W$.

## Примеры

### Пример 1

**Ввод:**
```
10 3
1 4 9
```

**Вывод:**
```
10
```

### Пример 2

**Ввод:**
```
73 5
19 23 31 17 18
```

**Вывод:**
```
73
```

### Пример 3

**Ввод:**
```
44 3
44 43 1
```

**Вывод:**
```
44
```
## Решение

main.cpp
```cpp
#include <iostream>
#include <vector>
#include <algorithm>


int main() {
    int W, n;
    std::cin >> W >> n;
    std::vector<int> weights(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> weights[i];
    }
    
    std::vector<int> dp(W + 1, 0);
    for (int wi : weights) {
        if (wi > W) continue;
        for (int w = W; w >= wi; --w) {
            dp[w] = std::max(dp[w], dp[w - wi] + wi);
        }
    }

    std::cout << dp[W] << '\n';

    return 0;
}
```
