# Сумма минимумов на отрезках

**Ограничение времени:** 1 с  
**Ограничение памяти:** 256.0 Мб  
**Ввод:** стандартный ввод или `input.txt`  
**Вывод:** стандартный вывод или `output.txt`

Дан массив $ a $, состоящий из $ n $ чисел, и целое число $ k $ ($ 1 \leq k \leq n $).  
Необходимо найти **сумму минимальных элементов** по всем **непрерывным подотрезкам** длины $ k $.

---

## Формат ввода

- Первая строка: целое число $ n $ — длина массива.  
- Вторая строка: целое число $ k $ — длина отрезка.  
- Третья строка: $ n $ целых чисел $ a_1, a_2, \dots, a_n $ — элементы массива.

## Формат вывода

Выведите одно целое число — сумму минимумов на всех отрезках длины $ k $.

---

## Примеры

### Пример 1

**Ввод:**
```
5
3
1 2 3 4 5
```

**Вывод:**
```
6
```

> Отрезки: `[1,2,3] → 1`, `[2,3,4] → 2`, `[3,4,5] → 3` → сумма = $1 + 2 + 3 = 6$

### Пример 2

**Ввод:**
```
5
2
1 2 2 1 3
```

**Вывод:**
```
5
```

> Отрезки: `[1,2]→1`, `[2,2]→2`, `[2,1]→1`, `[1,3]→1` → сумма = $1+2+1+1=5$

### Пример 3

**Ввод:**
```
9
3
1 2 3 4 5 4 3 2 1
```

**Вывод:**
```
16
```

### Пример 4

**Ввод:**
```
8
8
1 7 2 6 3 5 5 6
```

**Вывод:**
```
1
```

> Всего один отрезок — весь массив, минимум = 1

### Пример 5

**Ввод:**
```
5
1
1 1 1 1 1
```

**Вывод:**
```
5
```

> Каждый элемент — отрезок длины 1, минимум = 1, всего 5 таких

---

## Примечание

**Ограничения:**

- $ 1 \leq n \leq 3 \cdot 10^5 $
- $ 1 \leq k \leq n $
- $ 1 \leq a_i \leq 3 \cdot 10^5 $ для всех $ 1 \leq i \leq n $
## Решение

main.cpp
```cpp
#include <iostream>
#include <deque>
#include <vector>

int main() {
    int n, k;
    std::cin >> n >> k;
    std::vector<int> a(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> a[i];
    }

    std::deque<int> window;
    long long answer = 0;
    for (int i = 0; i <= n; ++i) {
        if (i >= k) {
            answer += a[window.front()];
        }

        // std::cout << "i = " << i 
        //           << " window.back(): " << (window.empty() ? -1 : a[window.front()])
        //           << " answer = " << answer << '\n';

        if (i == n) {
            continue;
        }

        while (!window.empty() && window.front() <= i - k) {
            window.pop_front();
        }

        while (!window.empty() && a[window.back()] >= a[i]) {
            window.pop_back();
        }

        window.push_back(i);
    }
    std::cout << answer << '\n';

    return 0;
}
```
