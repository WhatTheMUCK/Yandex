# Центр поддержки

**Ограничение времени:** 1 с  
**Ограничение памяти:** 64.0 Мб  
**Ввод:** стандартный ввод или `input.txt`  
**Вывод:** стандартный вывод или `output.txt`

В центр поддержки клиентов одновременно поступило $ n $ тикетов.  
Для каждого тикета известны:

- $ d_i $ — оценка длительности обработки,  
- $ w_i $ — приоритет (чем больше значение, тем **важнее** тикет).

Два сотрудника обрабатывают тикеты **параллельно**, каждый по одному тикету за раз, **без прерываний**.

## Правила выбора тикетов

В момент, когда **любой** из сотрудников освобождается:

- он выбирает среди **всех ещё не обработанных** тикетов тот, у которого:
  1. **максимальный приоритет** $ w_i $,
  2. при **равных приоритетах** — тикет с **меньшей длительностью** $ d_i $.

> Выбор происходит **динамически**: после завершения любого тикета пересчитывается очередь доступных тикетов.

## Задача

Определить **общее время разбора** — момент, когда **оба сотрудника завершат обработку всех тикетов**.

---

## Формат входных данных

- Первая строка: целое число $ n $ ($ 1 \leq n \leq 2 \cdot 10^5 $) — количество тикетов.
- Следующие $ n $ строк: по два целых числа $ d_i, w_i $  
  ($ 1 \leq d_i \leq 10^9,\; 1 \leq w_i \leq 10^9 $).

## Формат выходных данных

Выведите одно целое число $ T $ — момент окончания обработки **последнего** тикета.

---

## Примеры

### Пример 1

**Ввод:**
```
5
3 5
2 7
3 4
1 7
2 1
```

**Вывод:**
```
6
```

### Пример 2

**Ввод:**
```
4
5 10
2 5
3 5
4 1
```

**Вывод:**
```
9
```
## Решение

main.cpp
```cpp
#include <iostream>
#include <queue>

struct Compare {
    bool operator()(const std::pair<int, int>& lhs, const std::pair<int, int>& rhs) const {
        return std::tie(lhs.first, rhs.second) < std::tie(rhs.first, lhs.second);
    }
};

int main() {
    int n;
    std::cin >> n;
    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, Compare> pq;
    for (int i = 0; i < n; ++i) {
        int d, w;
        std::cin >> d >> w;
        pq.push({w, d});
    }

    long long timeFirst = 0, timeSecond = 0;
    while (!pq.empty()) {
        auto [_, time1] = pq.top();
        pq.pop();
        timeFirst += time1;
        while (!pq.empty() && timeSecond < timeFirst) {
            auto [_, time2] = pq.top();
            pq.pop();
            timeSecond += time2;
        }
    }

    std::cout << std::max(timeFirst, timeSecond) << '\n';
    return 0;
}
```
